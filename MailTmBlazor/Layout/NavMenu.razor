@using System.Net
@using MailTmBlazor.Infrastructure.Auth
@using MailTmBlazor.Infrastructure.MailTm
@inject NavigationManager Nav
@inject MailTmBlazor.Infrastructure.Auth.IAccountSession Session
@inject MailTmBlazor.Application.Abstractions.IAuthService Auth
@inject MailTmBlazor.Application.Abstractions.IMailboxService Mailbox
@inject IJSRuntime JS

<header class="topbar @desktopOffsetClass">
    <div class="topbar-left">
        <button class="icon-button nav-toggle" title="Open navigation" @onclick="ToggleDrawer">☰</button>
        <button class="email-pill" title="Copy address" @onclick="CopyEmail">@displayAddress</button>
        @if (copied)
        {
            <span class="pill-feedback">Copied</span>
        }
    </div>

    <div class="topbar-actions">
        <button class="icon-button" title="Theme toggle (coming soon)">
            <img src="https://www.svgrepo.com/show/310719/dark-theme.svg" alt="" class="icon-img">
        </button>
        <button class="icon-button" title="Language (coming soon)">
            <img src="https://www.svgrepo.com/show/506518/language.svg" alt="" class="icon-img">
        </button>
        <div class="avatar" title="@userLabel" @onclick="ToggleActions">@initial</div>
        @if (actionsOpen)
        {
            <div class="actions-menu">
                <button @onclick="CreateAccount">Create account</button>
                <button @onclick="Login">Login</button>
                <button @onclick="DeleteAccount">Delete account</button>
                <button @onclick="Logout">Logout</button>
            </div>
        }
    </div>
</header>

<div class="drawer-backdrop @(drawerOpen ? "show" : null)" @onclick="CloseDrawer"></div>
<nav class="drawer @(drawerOpen ? "open" : null)">
    <div class="drawer-header">
        <span class="brand">MailTmBlazor</span>
        <button class="icon-button mobile-only" @onclick="CloseDrawer">×</button>
    </div>
    <NavLink class="drawer-link" href="inbox" Match="NavLinkMatch.All" @onclick="CloseDrawer">
        <img src="https://www.svgrepo.com/show/533193/mail.svg" alt="" class="icon-img">
        <span>Inbox</span>
    </NavLink>
    <NavLink class="drawer-link" href="auth" @onclick="CloseDrawer">
        <img src="https://www.svgrepo.com/show/452026/auth-fingerprint.svg" alt="" class="icon-img">
        <span>Auth</span>
    </NavLink>
    <NavLink class="drawer-link" href="domains" @onclick="CloseDrawer">
        <img src="https://www.svgrepo.com/show/445722/domain.svg" alt="" class="icon-img">
        <span>Domains</span>
    </NavLink>
    <NavLink class="drawer-link" href="me" @onclick="CloseDrawer">
        <img src="https://www.svgrepo.com/show/512697/profile-1341.svg" alt="" class="icon-img">
        <span>Account</span>
    </NavLink>
    <div class="drawer-footer">
        <div class="divider"></div>
        <div class="quota-row">
            <span class="muted">Usage</span>
            <div class="progress-bar">
                <div class="progress-fill" style="width: @quotaPercent%;"></div>
            </div>
            <span class="muted">@usedMb / @quotaMb MB</span>
        </div>
        <a class="muted" href="https://docs.mail.tm" target="_blank" rel="noreferrer">API docs</a>
    </div>
</nav>

@if (showAuthModal)
{
    <div class="modal-backdrop" @onclick="CloseModal">
        <div class="modal-shell" @onclick:stopPropagation="true">
            <div class="modal-icon">
                <img src="https://www.svgrepo.com/show/380127/user-add-account-profile.svg" alt="" class="icon-img">
            </div>
            <h4>@(authMode == AuthMode.Create ? "Create an account" : "Sign in")</h4>
            <p class="muted small">Pick a name, domain, and password. A strong password is prefilled.</p>

            <div class="modal-field">
                <label>Email</label>
                <div class="modal-email-row">
                    <input class="form-control" value="@modalUsername" @oninput="e => modalUsername = e.Value?.ToString() ?? string.Empty" />
                    <select class="form-select modal-domain" value="@modalDomain" @onchange="e => modalDomain = e.Value?.ToString() ?? modalDomain">
                        @foreach (var d in domains)
                        {
                            <option value="@d" selected="@(modalDomain == d)">@d</option>
                        }
                    </select>
                </div>
            </div>

            <div class="modal-field">
                <label>Password</label>
                <input class="form-control" type="password" value="@modalPassword" @oninput="e => modalPassword = e.Value?.ToString() ?? string.Empty" />
            </div>

            @if (!string.IsNullOrWhiteSpace(modalError))
            {
                <p class="text-danger small">@modalError</p>
            }

            <div class="modal-actions">
                <button class="btn btn-outline-secondary" @onclick="CloseModal" disabled="@modalBusy">Cancel</button>
                <button class="btn btn-primary" @onclick="SubmitModal" disabled="@modalBusy">
                    @(modalBusy ? "Working…" : (authMode == AuthMode.Create ? "Create" : "Login"))
                </button>
            </div>
        </div>
    </div>
}

@code {
    private readonly string[] WordBank =
    [
        "bright", "swift", "shadow", "lumen", "ember", "north", "delta", "spruce", "amber", "vivid",
        "glow", "pixel", "prime", "dash", "orbit", "fable", "cobalt", "zenith", "river", "cedar"
    ];

    private const string AliasStorageKey = "anonEmail";
    private const string PasswordStorageKey = "anonPassword";
    private const string DomainStorageKey = "anonDomain";
    private static string? CachedDomain;
    private static Task<string?>? DomainFetchTask;
    private string displayAddress = string.Empty;
    private string initial = "?";
    private string userLabel = "Guest";
    private bool drawerOpen;
    private bool actionsOpen;
    private bool copied;
    private string desktopOffsetClass = string.Empty;
    private string? storedPassword;
    private string? domain;
    private bool ensuringAccount;
    private bool retriedDomain;
    private bool retriedLogin;
    private double quotaPercent;
    private string usedMb = "0";
    private string quotaMb = "0";
    private bool showAuthModal;
    private AuthMode authMode = AuthMode.Create;
    private string modalUsername = string.Empty;
    private string modalPassword = string.Empty;
    private string modalDomain = string.Empty;
    private string? modalError;
    private bool modalBusy;
    private List<string> domains = new();
    private bool navigating;

    protected override async Task OnInitializedAsync()
    {
        await EnsureDomainAsync();

        var session = await Session.GetAsync();
        if (session?.Address is not null)
        {
            displayAddress = session.Address;
            userLabel = $"Signed in as {session.Address}";
            domain ??= displayAddress.Split('@').LastOrDefault();
            SetUsage(session.Used, session.Quota);
            desktopOffsetClass = "desktop-offset";
            return;
        }

        var stored = await JS.InvokeAsync<string?>("localStorage.getItem", AliasStorageKey);
        storedPassword = await JS.InvokeAsync<string?>("localStorage.getItem", PasswordStorageKey);
        var storedDomain = await JS.InvokeAsync<string?>("localStorage.getItem", DomainStorageKey);
        if (!string.IsNullOrWhiteSpace(storedDomain))
        {
            domain ??= storedDomain;
            if (!domains.Contains(storedDomain)) domains.Add(storedDomain);
        }

        if (!string.IsNullOrWhiteSpace(stored))
        {
            displayAddress = stored!;
            domain ??= displayAddress.Split('@').LastOrDefault();
        }
        if (string.IsNullOrWhiteSpace(displayAddress) && !string.IsNullOrWhiteSpace(domain))
        {
            displayAddress = GenerateAlias();
            storedPassword = GeneratePassword();
            await PersistAnonCredentials(displayAddress, storedPassword, domain);
        }
        else if (!string.IsNullOrWhiteSpace(displayAddress) && !string.IsNullOrWhiteSpace(domain))
        {
            // If stored alias domain no longer matches available domain, regenerate to avoid 422.
            var aliasDomain = displayAddress.Split('@').LastOrDefault();
            if (!string.Equals(aliasDomain, domain, StringComparison.OrdinalIgnoreCase))
            {
                displayAddress = GenerateAlias();
                storedPassword = GeneratePassword();
                await PersistAnonCredentials(displayAddress, storedPassword, domain);
            }
        }
        await EnsureAccountAsync();

        initial = char.ToUpperInvariant(displayAddress.FirstOrDefault('u')).ToString();
        userLabel = session?.Address is not null ? $"Signed in as {session.Address}" : "Not signed in";

        // apply desktop offset class; JS-free check via window width would need JSInterop, so keep class always and hide with CSS when mobile
        desktopOffsetClass = "desktop-offset";
    }

    private string GenerateAlias()
    {
        if (string.IsNullOrWhiteSpace(domain)) throw new InvalidOperationException("No domain available.");
        var rnd = Random.Shared;
        var first = WordBank[rnd.Next(WordBank.Length)];
        var second = WordBank[rnd.Next(WordBank.Length)];
        return $"{first}-{second}@{domain}";
    }

    private static string GeneratePassword() => $"P@{Guid.NewGuid():N}".Substring(0, 16);

    private async Task PersistAnonCredentials(string alias, string? password, string? dom)
    {
        await JS.InvokeVoidAsync("localStorage.setItem", AliasStorageKey, alias);
        if (!string.IsNullOrWhiteSpace(password))
        {
            await JS.InvokeVoidAsync("localStorage.setItem", PasswordStorageKey, password);
        }
        if (!string.IsNullOrWhiteSpace(dom))
        {
            await JS.InvokeVoidAsync("localStorage.setItem", DomainStorageKey, dom);
        }
    }

    private async Task EnsureAccountAsync()
    {
        if (ensuringAccount) return;
        ensuringAccount = true;
        retriedDomain = false;
        retriedLogin = false;
        if (string.IsNullOrWhiteSpace(domain) || string.IsNullOrWhiteSpace(displayAddress) || !displayAddress.Contains('@'))
        {
            userLabel = "Unable to fetch domains";
            ensuringAccount = false;
            return;
        }
        try
        {
            var pwd = storedPassword ?? GeneratePassword();
            storedPassword = pwd;
            await PersistAnonCredentials(displayAddress, pwd, domain);

            var registerFailed = false;
            try
            {
                await Auth.RegisterAsync(displayAddress, pwd);
            }
            catch (MailTmApiException ex) when (ex.StatusCode == HttpStatusCode.UnprocessableEntity)
            {
                // Domain invalid → handled below, conflict → continue to login
                if (IsDomainInvalid(ex.Message) && !retriedDomain)
                {
                    retriedDomain = true;
                    await JS.InvokeVoidAsync("localStorage.removeItem", DomainStorageKey);
                    CachedDomain = null;
                    domain = null;
                    await EnsureDomainAsync();
                    if (string.IsNullOrWhiteSpace(domain))
                    {
                        userLabel = "Unable to fetch domains";
                        ensuringAccount = false;
                        return;
                    }
                    displayAddress = GenerateAlias();
                    storedPassword = GeneratePassword();
                    await PersistAnonCredentials(displayAddress, storedPassword, domain);
                    ensuringAccount = false;
                    await EnsureAccountAsync();
                    return;
                }
                registerFailed = true; // conflict/rate limit; try login anyway
            }

            try
            {
                var account = await Auth.LoginAndFetchAsync(displayAddress, pwd);
                userLabel = $"Signed in as {displayAddress}";
                SetUsage(account.Used, account.Quota);
                StateHasChanged();
            }
            catch (MailTmApiException ex) when (ex.StatusCode == HttpStatusCode.Unauthorized && !retriedLogin)
            {
                // Password mismatch for an existing alias → generate fresh creds and retry once.
                retriedLogin = true;
                await JS.InvokeVoidAsync("localStorage.removeItem", AliasStorageKey);
                await JS.InvokeVoidAsync("localStorage.removeItem", PasswordStorageKey);
                displayAddress = GenerateAlias();
                storedPassword = GeneratePassword();
                await PersistAnonCredentials(displayAddress, storedPassword, domain);
                ensuringAccount = false;
                await EnsureAccountAsync();
                return;
            }
            catch
            {
                if (!registerFailed)
                {
                    userLabel = "Unable to register/login";
                }
                else
                {
                    userLabel = "Registered/exists; login failed";
                }
            }
        }
        catch (MailTmApiException ex) when (ex.StatusCode == HttpStatusCode.UnprocessableEntity && !retriedDomain)
        {
            // domain invalid → refresh domain list and retry once
            retriedDomain = true;
            await JS.InvokeVoidAsync("localStorage.removeItem", DomainStorageKey);
            CachedDomain = null;
            domain = null;
            await EnsureDomainAsync();
            if (string.IsNullOrWhiteSpace(domain))
            {
                userLabel = "Unable to fetch domains";
            }
            else
            {
                displayAddress = GenerateAlias();
                storedPassword = GeneratePassword();
                await PersistAnonCredentials(displayAddress, storedPassword, domain);
                ensuringAccount = false;
                await EnsureAccountAsync();
                return;
            }
        }
        catch
        {
            userLabel = "Unable to register/login";
        }
        finally
        {
            ensuringAccount = false;
        }
    }

    private static bool IsDomainInvalid(string? message)
    {
        if (string.IsNullOrWhiteSpace(message)) return false;
        return message.Contains("domain", StringComparison.OrdinalIgnoreCase)
               || message.Contains("not valid", StringComparison.OrdinalIgnoreCase);
    }

    private void SetUsage(long used, long quota)
    {
        usedMb = Math.Round(used / 1_000_000d, 2).ToString("0.##");
        quotaMb = Math.Round(quota / 1_000_000d, 2).ToString("0.##");
        quotaPercent = quota > 0 ? Math.Clamp(used * 100d / quota, 0, 100) : 0;
    }

    private void ToggleDrawer() => drawerOpen = !drawerOpen;
    private void CloseDrawer() => drawerOpen = false;

    private void ToggleActions() => actionsOpen = !actionsOpen;

    private async Task CopyEmail()
    {
        try
        {
            await JS.InvokeVoidAsync("navigator.clipboard.writeText", displayAddress);
            copied = true;
            _ = Task.Delay(1200).ContinueWith(_ =>
            {
                copied = false;
                InvokeAsync(StateHasChanged);
            });
        }
        catch
        {
            copied = false;
        }
    }

    private async Task CreateAccount()
    {
        await ShowAuthModal(AuthMode.Create);
    }

    private async Task Login()
    {
        await ShowAuthModal(AuthMode.Login);
    }

    private async Task DeleteAccount()
    {
        var snap = await Session.GetAsync();
        if (snap is not null)
        {
            await Auth.DeleteAccountAsync(snap.Id);
        }
        await ClearClientStateAsync();
        NavigateSpa("/inbox", hardReload: true);
    }

    private async Task Logout()
    {
        await ClearClientStateAsync();
        NavigateSpa("/inbox", hardReload: true);
    }

    private async Task EnsureDomainAsync()
    {
        if (!string.IsNullOrWhiteSpace(domain)) return;

        var stored = await JS.InvokeAsync<string?>("localStorage.getItem", DomainStorageKey);
        if (!string.IsNullOrWhiteSpace(stored))
        {
            domain = stored;
            CachedDomain = domain;
            return;
        }

        if (!string.IsNullOrWhiteSpace(CachedDomain))
        {
            domain = CachedDomain;
            return;
        }

        domain = await GetDomainOnceAsync();

        if (!string.IsNullOrWhiteSpace(domain))
        {
            CachedDomain = domain;
            await JS.InvokeVoidAsync("localStorage.setItem", DomainStorageKey, domain);
            if (!domains.Contains(domain)) domains.Add(domain);
        }
    }

    private async Task<string?> GetDomainOnceAsync()
    {
        if (DomainFetchTask is null)
        {
            DomainFetchTask = FetchDomainAsync();
        }

        try { return await DomainFetchTask; }
        finally { DomainFetchTask = null; }
    }

    private async Task<string?> FetchDomainAsync()
    {
        try
        {
            var list = await Mailbox.GetDomainsAsync();
            domains = list.Select(d => d.Domain).ToList();
            return domains.FirstOrDefault();
        }
        catch
        {
            return null;
        }
    }

    private async Task ShowAuthModal(AuthMode mode)
    {
        authMode = mode;
        await EnsureDomainAsync();
        if (!string.IsNullOrWhiteSpace(domain) && !domains.Contains(domain)) domains.Add(domain);
        modalDomain = domain ?? domains.FirstOrDefault() ?? string.Empty;
        modalUsername = (displayAddress.Contains('@') ? displayAddress.Split('@')[0] : GenerateAlias().Split('@')[0]);
        modalPassword = storedPassword ?? GeneratePassword();
        modalError = null;
        showAuthModal = true;
    }

    private void CloseModal()
    {
        showAuthModal = false;
        modalBusy = false;
        modalError = null;
    }

    private async Task SubmitModal()
    {
        if (string.IsNullOrWhiteSpace(modalUsername) || string.IsNullOrWhiteSpace(modalDomain) || string.IsNullOrWhiteSpace(modalPassword))
        {
            modalError = "All fields are required.";
            return;
        }

        modalBusy = true;
        modalError = null;
        var address = $"{modalUsername}@{modalDomain}";

        try
        {
            if (authMode == AuthMode.Create)
            {
                try { await Auth.RegisterAsync(address, modalPassword); } catch { /* ignore conflicts */ }
            }

            var account = await Auth.LoginAndFetchAsync(address, modalPassword);
            displayAddress = account.Address;
            storedPassword = modalPassword;
            domain = modalDomain;
            await PersistAnonCredentials(displayAddress, storedPassword, domain);
            SetUsage(account.Used, account.Quota);
            userLabel = $"Signed in as {account.Address}";
            showAuthModal = false;
            actionsOpen = false;
            drawerOpen = false;
            StateHasChanged();
            Nav.NavigateTo("/inbox", forceLoad: true);
            return;
        }
        catch (Exception ex)
        {
            modalError = ex.Message;
        }
        finally
        {
            modalBusy = false;
            StateHasChanged();
        }
    }

    private enum AuthMode
    {
        Create,
        Login
    }

    private async Task ClearClientStateAsync()
    {
        await JS.InvokeVoidAsync("localStorage.removeItem", AliasStorageKey);
        await JS.InvokeVoidAsync("localStorage.removeItem", PasswordStorageKey);
        await JS.InvokeVoidAsync("localStorage.removeItem", DomainStorageKey);
        await JS.InvokeVoidAsync("localStorage.removeItem", "account");
        await Session.ClearAsync();
        displayAddress = string.Empty;
        storedPassword = null;
        domain = null;
        userLabel = "Not signed in";
        showAuthModal = false;
        actionsOpen = false;
        drawerOpen = false;
        navigating = false;
    }

    private void NavigateSpa(string uri, bool hardReload = false)
    {
        if (navigating) return;
        navigating = true;
        Nav.NavigateTo(uri, forceLoad: hardReload);
        navigating = false;
    }
}
